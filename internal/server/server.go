package server

import (
	"encoding/hex"
	"fmt"
	"log"
	"net"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/NHAS/reverse_ssh/internal"
	"github.com/NHAS/reverse_ssh/internal/nat"
	"github.com/NHAS/reverse_ssh/internal/server/data"
	"github.com/NHAS/reverse_ssh/internal/server/multiplexer"
	"github.com/NHAS/reverse_ssh/internal/server/tcp"
	"github.com/NHAS/reverse_ssh/internal/server/webhooks"
	"github.com/NHAS/reverse_ssh/internal/server/webserver"
	"github.com/NHAS/reverse_ssh/pkg/mux"
	"golang.org/x/crypto/ssh"
)

func CreateOrLoadServerKeys(privateKeyPath string) (ssh.Signer, error) {

	//If we have already created a private key (or there is one in the current directory) dont overwrite/create another one
	if _, err := os.Stat(privateKeyPath); os.IsNotExist(err) {

		privateKeyPem, err := internal.GeneratePrivateKey()
		if err != nil {
			return nil, fmt.Errorf("unable to generate private key, and no private key specified: %s", err)
		}

		err = os.WriteFile(privateKeyPath, privateKeyPem, 0600)
		if err != nil {
			return nil, fmt.Errorf("unable to write private key to disk: %s", err)
		}
	}

	privateBytes, err := os.ReadFile(privateKeyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load private key (%s): %s", privateKeyPath, err)
	}

	private, err := ssh.ParsePrivateKey(privateBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse private key: %s", err)
	}

	return private, nil
}

func tsAllowedRoles() map[string]bool {
	return map[string]bool{
		roleClient: true,
	}
}

type tsRelayBootstrap struct {
	mu sync.Mutex

	privateKeyPath string
	listenAddr     string
	private        ssh.Signer
	insecure       bool
	openproxy      bool
	dataDir        string
	timeout        int

	service *nat.Service
}

func newTSRelayBootstrap(privateKeyPath, listenAddr string, private ssh.Signer, insecure, openproxy bool, dataDir string, timeout int) *tsRelayBootstrap {
	return &tsRelayBootstrap{
		privateKeyPath: privateKeyPath,
		listenAddr:     listenAddr,
		private:        private,
		insecure:       insecure,
		openproxy:      openproxy,
		dataDir:        dataDir,
		timeout:        timeout,
	}
}

func (t *tsRelayBootstrap) EnsureToken() (string, error) {
	t.mu.Lock()
	defer t.mu.Unlock()

	if t.service != nil {
		return t.service.Token(), nil
	}

	privateKeyBytes, err := os.ReadFile(t.privateKeyPath)
	if err != nil {
		return "", fmt.Errorf("failed to read server private key for ts relay initialisation: %w", err)
	}

	service, err := nat.Start(nat.ServiceConfig{
		ListenAddr:     t.listenAddr,
		HostPrivateKey: privateKeyBytes,
	})
	if err != nil {
		return "", fmt.Errorf("failed to start ts relay transport: %w", err)
	}

	t.service = service

	log.Printf("ts relay transport enabled, callback token initialised")
	go StartSSHServerRestricted(
		service.Listener(),
		t.private,
		t.insecure,
		t.openproxy,
		t.dataDir,
		t.timeout,
		tsAllowedRoles(),
		true,
	)

	return service.Token(), nil
}

func (t *tsRelayBootstrap) Close() error {
	t.mu.Lock()
	defer t.mu.Unlock()

	if t.service == nil {
		return nil
	}

	err := t.service.Close()
	t.service = nil

	return err
}

func hasPersistedTSCallbackDownloads() (bool, error) {
	downloads, err := data.ListDownloads("")
	if err != nil {
		return false, err
	}

	for _, download := range downloads {
		callback := strings.TrimSpace(strings.ToLower(download.CallbackAddress))
		if strings.HasPrefix(callback, nat.DestinationPrefix) {
			return true, nil
		}
	}

	return false, nil
}

func bootstrapTSRelayWithRetry(relayBootstrap *tsRelayBootstrap, reason string) {
	if _, err := relayBootstrap.EnsureToken(); err != nil {
		log.Printf("failed to initialise ts relay transport (%s), retrying in background: %v", reason, err)
		go func() {
			ticker := time.NewTicker(15 * time.Second)
			defer ticker.Stop()

			for range ticker.C {
				if _, err := relayBootstrap.EnsureToken(); err != nil {
					log.Printf("ts relay retry failed (%s): %v", reason, err)
					continue
				}

				log.Printf("ts relay transport initialised (%s)", reason)
				return
			}
		}()
		return
	}

	log.Printf("ts relay transport initialised (%s)", reason)
}

func Run(addr, dataDir, connectBackAddress string, autogeneratedConnectBack bool, TLSCertPath, TLSKeyPath string, insecure, enabledDownloads, enableTLS, openproxy, forceTSRelay bool, timeout int) {
	c := mux.MultiplexerConfig{
		Control:           true,
		Downloads:         enabledDownloads,
		TLS:               enableTLS,
		TLSCertPath:       TLSCertPath,
		TLSKeyPath:        TLSKeyPath,
		AutoTLSCommonName: connectBackAddress,
		TcpKeepAlive:      timeout,
		PollingAuthChecker: func(key string, addr net.Addr) bool {

			authorizedKey, err := hex.DecodeString(key)
			if err != nil {
				return false
			}

			pubKey, err := ssh.ParsePublicKey(authorizedKey)
			if err != nil {
				return false
			}

			_, err = CheckAuth(filepath.Join(dataDir, "authorized_controllee_keys"), pubKey, getIP(addr.String()), insecure)
			return err == nil

		},
	}

	privateKeyPath := filepath.Join(dataDir, "id_ed25519")

	log.Println("Version: ", internal.Version)
	var err error
	multiplexer.ServerMultiplexer, err = mux.ListenWithConfig("tcp", addr, c)
	if err != nil {
		log.Fatalf("Failed to listen on %s (%s)", addr, err)
	}
	defer multiplexer.ServerMultiplexer.Close()

	log.Printf("Listening on %s\n", addr)

	private, err := CreateOrLoadServerKeys(privateKeyPath)
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Loading private key from: %s\n", privateKeyPath)

	log.Println("Server key fingerprint: ", internal.FingerprintSHA256Hex(private.PublicKey()))

	webserver.ResetTSRelay()
	relayBootstrap := newTSRelayBootstrap(privateKeyPath, addr, private, insecure, openproxy, dataDir, timeout)
	webserver.SetTSBootstrap(relayBootstrap.EnsureToken)
	defer func() {
		webserver.ResetTSRelay()
		if err := relayBootstrap.Close(); err != nil {
			log.Printf("failed to close ts relay transport: %v", err)
		}
	}()

	if enabledDownloads {
		if len(connectBackAddress) == 0 {
			connectBackAddress = addr
		}
		go webserver.Start(multiplexer.ServerMultiplexer.HTTPDownloadRequests(), connectBackAddress, autogeneratedConnectBack, "../", dataDir, private.PublicKey())
		go tcp.Start(multiplexer.ServerMultiplexer.TCPDownloadRequests())
	}

	err = data.LoadDatabase(filepath.Join(dataDir, "data.db"))
	if err != nil {
		log.Fatal(err)
	}

	if forceTSRelay {
		bootstrapTSRelayWithRetry(relayBootstrap, "forced startup")
	} else {
		hasTSDownloads, err := hasPersistedTSCallbackDownloads()
		if err != nil {
			log.Printf("unable to inspect downloads for ts callback bootstrap: %v", err)
		} else if hasTSDownloads {
			bootstrapTSRelayWithRetry(relayBootstrap, "persisted ts callbacks")
		}
	}

	go webhooks.StartWebhooks()

	StartSSHServer(multiplexer.ServerMultiplexer.ControlRequests(), private, insecure, openproxy, dataDir, timeout)
}
